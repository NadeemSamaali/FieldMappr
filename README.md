# FieldMappr
Console based software mapping electric fields in three dimensions with the help of user inputted configuration of points, rods and/or rings of charge.

### **Model and Numerical Methods**

For the code, important libraries were imported to obtain the desired output. These libraries are numpy, matplotlib.pyplot,  Axes3D. To obtain the electric field,  Coulomb’s constant was specified as k to be able to simplify the code. This constant has a value of $8.99 \times 10^9$ and is necessary to calculate the electric field of point charges. The three dimensional bounds of the simulation are defined to have a minimum value of $-25$ and a maximum value of $25$ for the axis $x$, $y$ and $z$, which allows us to see the electric field clearly compared to the size of the point charges, rods and ring present. This size was determined because it is not too big in a way where the charges aren’t clear and not too small where the electric field is incomprehensible. The step size has a value of $6.25$, which allows the graph to have a good resolution and the code to computate rather quickly.  To show the electric field, many functions are used. These functions are stored in a class created named $E_{map}$ which will allow the visualization of the electric field. This will allow the creation of different graphs for different types of arrangements more quickly. In addition, the class $E_{map}$ containts a list named *charge_map*, where each point charge used in the simulation will be stored.

* `__unit_vector` calculates the components $i,j,k$ of an arbitrary vector such that its magnitude is equal to $1$. `__unit_vector` is an internal function, meaning that other methods use this function for their own calculations.
* `__E` calculates the vectorial value of the electric field at a point $p$ due to charge $Q$ located at point $q$. It calculates the magnitude of said electric field by using Coulomb’s equation $k \frac{Q}{d^2}$ where $d$ is the distance, and then, to obtain the position, multiplies it with the unit vectors calculated by the function `__unit_vector` between the two positions $p$ and $q$. This will allow us to add the electric fields of each point charge  to obtain the final electric field and graph it.
* `build_rod` approximates a rod of charge as multiple point charges alinged in a segment of a linear path, each spaced by a factor of $dl$. The charge values of each point charge within the rod are calculated with the equation $dq = Q \cdot \frac{dl}{l}$, where $Q$ is the total charge of the rod and $l$ is its length in meters. Then, the function stores in *charge_map* the point charges used to approximate the rod into 4-tuples containing their position in 3-space and their charge value of $dq$.
* `build_ring` approximates a ring of charge as a group of point charges alligned on a circular path. Firts, it sets the angle steps $dt$ to one degree (or $\frac{\pi}{180}$ radians) to obtain an accurate answer. From $dt$, the function generates a list containing all degrees between $0$ and $2\pi$ with step $dt$. This list, called *angles*, will be used later by the function to itterate through it when outputing the ring of charge.

    Then, the function converts the center coordinate of the ring $c$ into an numpy array. To continue, it finds two vectors $\vec{v}_1$ and $\vec{v}_2$ perpendicular to the normal vector $\vec{u}$ of the ring plane. $\vec{v}_1$
    represents any arbitrary perpendicular vector to the normal $\vec{u}$ of the ring. In our code we chose to define $\vec{v}_1$ to result form the following transformation :  

    $$\vec{u} = (a,b,c) \rightarrow \vec{v}_1 = (b, -a, 0)$$

    So we permutate the first and second component of the normal with respect to each other, inverse the sign of the second component and set the third component to $0$. It is important to note that the vectors $\vec{u}$, $\vec{v}_1$ and $\vec{v}_2$ are stored as numpy arrays to facilitate vector manipulations.
    
    Its magnitude is then calculated and transformed into unit vector form. In the case $a,b = 0$, the code then makes sure $\vec{v}_1$ isn’t equal to $\vec{0}$ by assigning it the value $(0,1,0)$. $\vec{v}_2$ is obtained by the cross product of $\vec{v}_1$ and the normal vector $\vec{u}$. The function then iterates the equations  $\vec{r}(t)= (x_0, y_0,z_0) + r(cos t\cdot \vec{v}_1+ sin t\cdot \vec{v}_2)$ over the list *angles* to find the coordinates of the point charges that will be used to build the ring of charge. The function will then append to *charge_map* the coordinates of the charges as 4-tuples, where the three first positions represent the charges' location in 3-space, and the 4th position stores its charge value $dq$, found by the following equation $dq = Q \cdot \frac{dt}{2\pi}$

* `__build_field` is a function that stores the vectorial value of the electric field caused by the charges stored in *charge_map* at each point of a numpy meshgrid. The function takes as input the meshgrid values of X, Y, and Z and calculates the resulting vectors of the electric field at each of these points with the use of the function ***E***, which iterates through each 4-tuple stored in *charge_map* using a for loop, and summing all the components together. The function will then output a 3-tuple $(dE_x, dE_y, dE_z)$, where each position is a meshgrid of the components of the electric field in each plane.


  
